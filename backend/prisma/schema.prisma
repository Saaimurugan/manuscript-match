// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  passwordHash String @map("password_hash")
  role      String   @default("USER") // UserRole as string
  status    String   @default("ACTIVE") // UserStatus as string
  name      String?
  phone     String?
  department String?
  bio       String?
  profileImage String? @map("profile_image")
  blockedAt DateTime? @map("blocked_at")
  blockedBy String?  @map("blocked_by")
  invitedBy String?  @map("invited_by")
  invitationToken String? @map("invitation_token")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  // Relations
  processes Process[]
  activityLogs ActivityLog[]
  userPermissions UserPermission[]
  invitedUsers User[] @relation("UserInvitations")
  inviter User? @relation("UserInvitations", fields: [invitedBy], references: [id])
  blockedByUser User? @relation("UserBlocking", fields: [blockedBy], references: [id])
  blockedUsers User[] @relation("UserBlocking")
  sentInvitations UserInvitation[] @relation("InvitationSender")
  grantedPermissions UserPermission[] @relation("UserPermissionGranter")
  sessions UserSession[]
  
  @@map("users")
}

model Process {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  title       String
  status      String   // ProcessStatus as string
  currentStep String   @map("current_step") // ProcessStep as string
  metadata    String?  // JSON string
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  // Relations
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  processAuthors ProcessAuthor[]
  shortlists   Shortlist[]
  activityLogs ActivityLog[]
  
  @@map("processes")
}

model Author {
  id               String   @id @default(uuid())
  name             String
  email            String?
  publicationCount Int      @default(0) @map("publication_count")
  clinicalTrials   Int      @default(0) @map("clinical_trials")
  retractions      Int      @default(0)
  researchAreas    String?  // JSON array as string
  meshTerms        String?  @map("mesh_terms") // JSON array as string
  createdAt        DateTime @default(now()) @map("created_at")
  
  // Relations
  processAuthors ProcessAuthor[]
  affiliations   AuthorAffiliation[]
  
  @@map("authors")
}

model Affiliation {
  id              String   @id @default(uuid())
  institutionName String   @map("institution_name")
  department      String?
  address         String
  country         String
  createdAt       DateTime @default(now()) @map("created_at")
  
  // Relations
  authorAffiliations AuthorAffiliation[]
  
  @@map("affiliations")
}

model AuthorAffiliation {
  id            String @id @default(uuid())
  authorId      String @map("author_id")
  affiliationId String @map("affiliation_id")
  
  // Relations
  author      Author      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  affiliation Affiliation @relation(fields: [affiliationId], references: [id], onDelete: Cascade)
  
  @@unique([authorId, affiliationId])
  @@map("author_affiliations")
}

model ProcessAuthor {
  id               String   @id @default(uuid())
  processId        String   @map("process_id")
  authorId         String   @map("author_id")
  role             String   // AuthorRole as string
  validationStatus String?  @map("validation_status") // JSON string
  addedAt          DateTime @default(now()) @map("added_at")
  
  // Relations
  process Process @relation(fields: [processId], references: [id], onDelete: Cascade)
  author  Author  @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  @@unique([processId, authorId, role])
  @@map("process_authors")
}

model Shortlist {
  id        String   @id @default(uuid())
  processId String   @map("process_id")
  name      String
  createdAt DateTime @default(now()) @map("created_at")
  
  // Relations
  process Process @relation(fields: [processId], references: [id], onDelete: Cascade)
  
  @@map("shortlists")
}

model ActivityLog {
  id           String      @id @default(uuid())
  userId       String?     @map("user_id") // Made nullable for system logs
  processId    String?     @map("process_id")
  action       String
  details      String?     // JSON string
  ipAddress    String?     @map("ip_address")
  userAgent    String?     @map("user_agent")
  resourceType String?     @map("resource_type")
  resourceId   String?     @map("resource_id")
  signature    String?     // Cryptographic signature for integrity
  previousHash String?     @map("previous_hash") // Hash of previous log entry
  timestamp    DateTime    @default(now())
  
  // Relations
  user    User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
  process Process? @relation(fields: [processId], references: [id], onDelete: Cascade)
  auditChain AuditChain?
  
  @@map("activity_logs")
}

model UserInvitation {
  id        String   @id @default(uuid())
  email     String
  role      String   // UserRole as string
  token     String   @unique
  invitedBy String   @map("invited_by")
  invitedAt DateTime @default(now()) @map("invited_at")
  expiresAt DateTime @map("expires_at")
  acceptedAt DateTime? @map("accepted_at")
  status    String   @default("PENDING") // InvitationStatus as string
  
  // Relations
  inviter User @relation("InvitationSender", fields: [invitedBy], references: [id], onDelete: Cascade)
  
  @@map("user_invitations")
}

model Permission {
  id          String   @id @default(uuid())
  name        String   @unique
  description String
  resource    String   // Resource type (users, processes, system)
  action      String   // Action type (create, read, update, delete, manage)
  createdAt   DateTime @default(now()) @map("created_at")
  
  // Relations
  userPermissions UserPermission[]
  rolePermissions RolePermission[]
  
  @@map("permissions")
}

model UserPermission {
  id           String   @id @default(uuid())
  userId       String   @map("user_id")
  permissionId String   @map("permission_id")
  grantedBy    String   @map("granted_by")
  grantedAt    DateTime @default(now()) @map("granted_at")
  
  // Relations
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  granter    User       @relation("UserPermissionGranter", fields: [grantedBy], references: [id])
  
  @@unique([userId, permissionId])
  @@map("user_permissions")
}

model RolePermission {
  id           String @id @default(uuid())
  role         String // UserRole as string
  permissionId String @map("permission_id")
  
  // Relations
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  
  @@unique([role, permissionId])
  @@map("role_permissions")
}

model UserSession {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  token     String   @unique
  ipAddress String?  @map("ip_address")
  userAgent String?  @map("user_agent")
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  expiresAt DateTime @map("expires_at")
  lastUsedAt DateTime @default(now()) @map("last_used_at")
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_sessions")
}

model AuditChain {
  id           String   @id @default(uuid())
  logId        String   @unique @map("log_id")
  hash         String   // Hash of the log entry
  previousHash String?  @map("previous_hash") // Hash of previous chain entry
  signature    String   // Cryptographic signature
  timestamp    DateTime
  blockIndex   Int      @map("block_index") // Sequential block number
  
  // Relations
  log ActivityLog @relation(fields: [logId], references: [id], onDelete: Cascade)
  
  @@map("audit_chain")
}

// Note: SQLite doesn't support enums, so we use string constants in TypeScript
// These enums are defined in src/types/index.ts